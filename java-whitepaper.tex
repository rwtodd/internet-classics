% An early Java(TM) whitepaper
\newcount\chapcnt \chapcnt=0\newcount\seccnt \seccnt=0%
\newcount\subseccnt \subseccnt=0%
\def\tmk{$^{\rm TM}$}%
\def\Java{Java\tmk}\def\HotJava{HotJava\tmk}%
\def\chapter#1.{\seccnt=0\subseccnt=0\advance\chapcnt by1%
\bigbreak\centerline{\bf Chapter \the\chapcnt: #1}}%
\def\\{\hfil\break}%
\def\chapquote#1#2{{\medbreak\narrower\noindent#1\smallskip\hskip 0.5in--- #2\medbreak}}%
\def\section#1.{\subseccnt=0\advance\seccnt by1%
\medbreak\noindent{\bf \the\chapcnt.\the\seccnt: #1}\par\noindent\ignorespaces}%
\def\subsection#1.{\advance\subseccnt by1%
\medbreak\noindent{\bf \the\chapcnt.\the\seccnt.\the\subseccnt: #1}\par\noindent\ignorespaces}%
\def\heading#1.{\medbreak\noindent{\bf #1}\par\noindent\ignorespaces}%
\def\bitem{\item{$\bullet$}}%
\def\oneliner#1{\begingroup\medbreak\narrower\tt #1\medbreak\endgroup}%
\catcode`\|=13 \def|{\begingroup\tt\def|{\endgroup}}%
%
\centerline{\bf The Java Language Environment White Paper}
\centerline{May 1996}
\centerline{James Gosling}
\centerline{Henry McGilton}
\chapter Introduction to \Java~Technology.
\chapquote{The Next Stage of the Known,\\
Or a Completely New Paradigm?}{Taiichi Sakaiya, {\sl The Knowledge-Value Revolution}}

\heading The Software Developer's Burden. Imagine you're a software application
developer. Your programming language of choice (or the language that's been
foisted on you) is C or C++. You've been at this for quite a while and your job
doesn't seem to be getting any easier. These past few years you've seen the
growth of multiple incompatible hardware architectures, each supporting
multiple incompatible operating systems, with each platform operating with one
or more incompatible graphical user interfaces. Now you're supposed to cope
with all this and make your applications work in a distributed client-server
environment. The growth of the Internet, the World-Wide Web, and ``electronic
commerce'' have introduced new dimensions of complexity into the development
process.

The tools you use to develop applications don't seem to help you much. You're
still coping with the same old problems; the fashionable new object-oriented
techniques seem to have added new problems without solving the old ones. You
say to yourself and your friends, ``There has to be a better way!''

\heading The Better Way is Here Now. Now there is a better way --- the \Java{}
programming language platform from Sun Microsystems. Imagine, if you will, this
development world $\ldots$
{\medbreak\narrower
\bitem Your programming language is object oriented, yet it's still dead simple.
\bitem Your development cycle is much faster because Java technology is
interpreted. The compile-link-load-test-crash-debug cycle is obsolete---now you
just compile and run.
\bitem Your applications are portable across multiple platforms. Write your
applications once, and you never need to port them---they
will run without modification on multiple operating systems and hardware
architectures.
\bitem Your applications are robust because the Java runtime environment
manages memory for you.
\bitem Your interactive graphical applications have high performance because
multiple concurrent threads of activity in your application are supported by
the multithreading built into the Java programming language and runtime
platform.
\bitem Your applications are adaptable to changing environments because you can
dynamically download code modules from anywhere on the network.
\bitem Your end users can trust that your applications are secure, even though
they're downloading code from all over the Internet; the Java runtime
environment has built-in protection against viruses and tampering.
\medbreak}
\noindent You don't need to dream about these features. They're here now. The
Java programming language platform provides a portable, interpreted,
high-performance, simple, object-oriented programming language and supporting
run-time environment. This introductory chapter provides you with a brief look
at the main design goals of the Java system; the remainder of this paper
examines the features of Java in more detail.

The last chapter of this paper describes the \HotJava~Browser. The HotJava
Browser is an innovative World-Wide Web browser, and the first major
applications written using the Java platform. It is the first browser to
dynamically download and execute Java code fragments from anywhere on the
Internet, and can do so in a secure manner.

\section Beginnings of the \Java~Programming Language Project.
The \Java~programming language is designed to meet the challenges of
application development in the context of heterogeneous, network-wide
distributed environments. Paramount among these challenges is secure delivery
of applications that consume the minimum of system resources, can run on any
hardware and software platform, and can be extended dynamically.

The Java programming language originated as part of a research project to
develop advanced software for a wide variety of network devices and embedded
systems. The goal was to develop a small, reliable, portable, distributed,
real-time operating platform. When the project started, C++ was the language of
choice. But over time the difficulties encountered with C++ grew to the point
where the problems could best be addressed by creating an entirely new language
platform. Design and architecture decisions drew from a variety of languages
such as Eiffel, SmallTalk, Objective C, and Cedar/Mesa. The result is a
language platform that has proven ideal for developing secure, distributed,
network-based end-user applications in environments ranging from
network-embedded devices to the World-Wide Web and the desktop.

\section Design Goals of the \Java~Programming Language.
The design requirements of the JavaTM programming language are driven by the
nature of the computing environments in which software must be deployed. The
massive growth of the Internet and the World-Wide Web leads us to a completely
new way of looking at development and distribution of software. To live in the
world of electronic commerce and distribution, Java technology must enable the
development of secure, high performance, and highly robust applications on
multiple platforms in heterogeneous, distributed networks.

Operating on multiple platforms in heterogeneous networks invalidates the
traditional schemes of binary distribution, release, upgrade, patch, and so on.
To survive in this jungle, the Java programming language must be architecture
neutral, portable, and dynamically adaptable.

The system that emerged to meet these needs is simple, so it can be easily
programmed by most developers; familiar, so that current developers can easily
learn the Java programming language; object oriented, to take advantage of
modern software development methodologies and to fit into distributed
client-server applications; multithreaded, for high performance in applications
that need to perform multiple concurrent activities, such as multimedia; and
interpreted, for maximum portability and dynamic capabilities.

Together, the above requirements comprise quite a collection of buzzwords, so
let's examine some of them and their respective benefits before going on.

\subsection Simple, Object Oriented, and Familiar. Primary characteristics of
the Java programming language include a simple language that can be programmed
without extensive programmer training while being attuned to current software
practices. The fundamental concepts of Java technology are grasped quickly;
programmers can be productive from the very beginning.

The Java programming language is designed to be object oriented from the ground
up. Object technology has finally found its way into the programming mainstream
after a gestation period of thirty years. The needs of distributed,
client-server based systems coincide with the encapsulated, message-passing
paradigms of object-based software. To function within increasingly complex,
network-based environments, programming systems must adopt object-oriented
concepts. Java technology provides a clean and efficient object-based
development platform.

Programmers using the Java programming language can access existing libraries
of tested objects that provide functionality ranging from basic data types
through I/O and network interfaces to graphical user interface toolkits. These
libraries can be extended to provide new behavior.

Even though C++ was rejected as an implementation language, keeping the Java
programming language looking like C++ as far as possible results in it being a
familiar language, while removing the unnecessary complexities of C++. Having
the Java programming language retain many of the object-oriented features and
the "look and feel" of C++ means that programmers can migrate easily to the
Java platform and be productive quickly.


\subsection Robust and Secure. The Java programming language is designed for
creating highly reliable software. It provides extensive compile-time checking,
followed by a second level of run-time checking. Language features guide
programmers towards reliable programming habits.

The memory management model is extremely simple: objects are created with a {\tt new}
operator. There are no explicit programmer-defined pointer data types, no
pointer arithmetic, and automatic garbage collection. This simple memory
management model eliminates entire classes of programming errors that bedevil C
and C++ programmers. You can develop Java code with confidence that the system
will find many errors quickly and that major problems won't lay dormant until
after your production code has shipped.

Java technology is designed to operate in distributed environments, which means
that security is of paramount importance. With security features designed into
the language and run-time system, Java technology lets you construct
applications that can't be invaded from outside. In the network environment,
applications written in the Java programming language are secure from intrusion
by unauthorized code attempting to get behind the scenes and create viruses or
invade file systems.

\subsection Architecture Neutral and Portable.
Java technology is designed to support applications that will be deployed into
heterogeneous network environments. In such environments, applications must be
capable of executing on a variety of hardware architectures. Within this
variety of hardware platforms, applications must execute atop a variety of
operating systems and interoperate with multiple programming language
interfaces. To accommodate the diversity of operating environments, the Java
Compiler\tmk~product generates bytecodes---an architecture neutral intermediate
format designed to transport code efficiently to multiple hardware and software
platforms. The interpreted nature of Java technology solves both the binary
distribution problem and the version problem; the same Java programming
language byte codes will run on any platform.

Architecture neutrality is just one part of a truly portable system. Java
technology takes portability a stage further by being strict in its definition
of the basic language. Java technology puts a stake in the ground and specifies
the sizes of its basic data types and the behavior of its arithmetic operators.
Your programs are the same on every platform---there are no data type
incompatibilities across hardware and software architectures.

The architecture-neutral and portable language platform of Java technology is
known as the Java virtual machine. It's the specification of an abstract
machine for which Java programming language compilers can generate code.
Specific implementations of the Java virtual machine for specific hardware and
software platforms then provide the concrete realization of the virtual
machine. The Java virtual machine is based primarily on the POSIX interface
specification---an industry-standard definition of a portable system interface.
Implementing the Java virtual machine on new architectures is a relatively
straightforward task as long as the target platform meets basic requirements
such as support for multithreading.

\subsection High Performance.
Performance is always a consideration. The Java platform achieves superior
performance by adopting a scheme by which the interpreter can run at full speed
without needing to check the run-time environment. The automatic garbage
collector runs as a low-priority background thread, ensuring a high probability
that memory is available when required, leading to better performance.
Applications requiring large amounts of compute power can be designed such that
compute-intensive sections can be rewritten in native machine code as required
and interfaced with the Java platform. In general, users perceive that
interactive applications respond quickly even though they're interpreted.

\subsection Interpreted, Threaded, and Dynamic.
The Java interpreter can execute Java bytecodes directly on any machine to
which the interpreter and run-time system have been ported. In an interpreted
platform such as Java technology-based system, the link phase of a program is
simple, incremental, and lightweight. You benefit from much faster development
cycles---prototyping, experimentation, and rapid development are the normal
case, versus the traditional heavyweight compile, link, and test cycles.

Modern network-based applications, such as the \HotJava~Browser for the World
Wide Web, typically need to do several things at the same time. A user working
with HotJava Browser can run several animations concurrently while downloading
an image and scrolling the page. Java technology's multithreading capability
provides the means to build applications with many concurrent threads of
activity. Multithreading thus results in a high degree of interactivity for the
end user.

The Java platform supports multithreading at the language level with the
addition of sophisticated synchronization primitives: the language library
provides the Thread class, and the run-time system provides monitor and
condition lock primitives. At the library level, moreover, Java technology's
high-level system libraries have been written to be thread safe: the
functionality provided by the libraries is available without conflict to
multiple concurrent threads of execution.

While the Java Compiler is strict in its compile-time static checking, the
language and run-time system are dynamic in their linking stages. Classes are
linked only as needed. New code modules can be linked in on demand from a
variety of sources, even from sources across a network. In the case of the
HotJava Browser and similar applications, interactive executable code can be
loaded from anywhere, which enables transparent updating of applications. The
result is on-line services that constantly evolve; they can remain innovative
and fresh, draw more customers, and spur the growth of electronic commerce on
the Internet.

\section The Java Platform---a New Approach to Distributed Computing.
Taken individually, the characteristics discussed above can be found in a
variety of software development platforms. What's completely new is the manner
in which Java technology and its runtime environment have combined them to
produce a flexible and powerful programming system.

Developing your applications using the Java programming language results in
software that is portable across multiple machine architectures, operating
systems, and graphical user interfaces, secure, and high performance. With Java
technology, your job as a software developer is much easier---you focus your
full attention on the end goal of shipping innovative products on time, based
on the solid foundation of the Java platform. The better way to develop
software is here, now, brought to you by the Java platform.

\chapter Java---Simple and Familiar.
\chapquote{You know you've achieved perfection in design,\\
Not when you have nothing more to add,\\
But when you have nothing more to take away.}{Antoine de Saint Exupery}

\noindent In his science-fiction novel, {\sl The Rolling Stones}, Robert~A.~Heinlein comments:

Every technology goes through three stages: first a crudely simple and quite
unsatisfactory gadget; second, an enormously complicated group of gadgets
designed to overcome the shortcomings of the original and achieving thereby
somewhat satisfactory performance through extremely complex compromise; third,
a final proper design therefrom.

Heinlein's comment could well describe the evolution of many programming
languages. Java presents a new viewpoint in the evolution of programming
languages---creation of a small and simple language that's still sufficiently
comprehensive to address a wide variety of software application development.
Although Java is superficially similar to C and C++, Java gained its simplicity
from the systematic removal of features from its predecessors. This chapter
discusses two of the primary design features of Java, namely, it's simple (from
removing features) and familiar (because it looks like C and C++). The next
chapter discusses Java's object-oriented features in more detail. At the end of
this chapter you'll find a discussion on features eliminated from C and C++ in
the evolution of Java.

\heading Design Goals.
Simplicity is one of Java's overriding design goals. Simplicity and removal of
many ``features'' of dubious worth from its C and C++ ancestors keep Java
relatively small and reduce the programmer's burden in producing reliable
applications. To this end, Java design team examined many aspects of the
``modern'' C and C++ languages1 to determine features that could be eliminated in
the context of modern object-oriented programming.

Another major design goal is that Java look familiar to a majority of
programmers in the personal computer and workstation arenas, where a large
fraction of system programmers and application programmers are familiar with C
and C++. Thus, Java ``looks like'' C++. Programmers familiar with C, Objective C,
C++, Eiffel, Ada, and related languages should find their Java language
learning curve quite short---on the order of a couple of weeks.

To illustrate the simple and familiar aspects of Java, we follow the tradition
of a long line of illustrious programming books by showing you the |HelloWorld|
program. It's about the simplest program you can write that actually does
something. Here's |HelloWorld| implemented in Java.
{\medbreak\narrower\obeylines\obeyspaces\tt
class HelloWorld $\{$
\hskip 0.3in static public void main(String args[]) $\{$
\hskip 0.6in    System.out.println("Hello world!");
\hskip 0.3in $\}$
$\}$\medbreak}
\noindent This example declares a class named |HelloWorld|. Classes are discussed
in the next chapter on object-oriented programming, but in general we assume
the reader is familiar with object technology and understands the basics of
classes, objects, instance variables, and methods.

Within the |HelloWorld| class, we declare a single method called |main()| which in
turn contains a single method invocation to display the string ``Hello world!''
on the standard output. The statement that prints ``Hello world!'' does so by
invoking the |println| method of the |out|~object. The |out|~object is a class
variable in the |System| class that performs output operations on files. That's
all there is to |HelloWorld|.

\section Main Features of the \Java~Programming Language.
The JavaTM programming language follows C++ to some degree, which carries the
benefit of it being familiar to many programmers. This section describes the
essential features of the Java programming language and points out where the
language diverges from its ancestors C and C++.

\subsection Primitive Data Types.
Other than the primitive data types discussed here, everything in the Java
programming language is an object. Even the primitive data types can be
encapsulated inside library-supplied objects if required. The Java programming
language follows C and C++ fairly closely in its set of basic data types, with
a couple of minor exceptions. There are only three groups of primitive data
types, namely, numeric types, character types, and Boolean types.

{\bf Numeric Data Types.} Integer numeric types are 8-bit byte, 16-bit short,
32-bit int, and 64-bit long. The 8-bit byte data type in Java has replaced the
old C and C++ char data type. Java places a different interpretation on the
char data type, as discussed below.

There is no unsigned type specifier for integer data types in Java.

Real numeric types are 32-bit float and 64-bit double. Real numeric types and
their arithmetic operations are as defined by the IEEE 754 specification. A
floating point literal value, like 23.79, is considered double by default; you
must explicitly cast it to float if you wish to assign it to a float variable.

{\bf Character Data Types.} Java language character data is a departure from
traditional C. Java's char data type defines a sixteen-bit Unicode character.
Unicode characters are unsigned 16-bit values that define character codes in
the range 0 through 65,535. If you write a declaration such as
\oneliner{char  myChar = 'Q';}
\noindent you get a Unicode (16-bit unsigned value) type initialized to the
Unicode value of the character Q. By adopting the Unicode character set
standard for its character data type, Java language applications are amenable
to internationalization and localization, greatly expanding the market for
world-wide applications.

{\bf Boolean Data Types.} Java added a Boolean data type as a primitive type,
tacitly ratifying existing C and C++ programming practice, where developers
define keywords for TRUE and FALSE or YES and NO or similar constructs. A Java
boolean variable assumes the value true or false. A Java programming language
boolean is a distinct data type; unlike common C practice, a Java programming
language boolean type can't be converted to any numeric type.

\subsection Arithmetic and Relational Operators.
All the familiar C and C++ operators apply. The Java programming language has
no unsigned data types, so the >>> operator has been added to the language to
indicate an unsigned (logical) right shift. Java also uses the + operator for
string concatenation; concatenation is covered below in the discussion on
strings.

\subsection Arrays.
In contrast to C and C++, the Java programming language arrays are first-class
language objects. An array in the Java programming language is a real object
with a run-time representation. You can declare and allocate arrays of any
type, and you can allocate arrays of arrays to obtain multi-dimensional arrays.

You declare an array of, say, Points (a class you've declared elsewhere) with a
declaration like this:
\oneliner{Point  myPoints[];}
\noindent This code states that myPoints is an uninitialized array of Points.
At this time, the only storage allocated for myPoints is a reference handle. At
some future time you must allocate the amount of storage you need, as in:
\oneliner{myPoints = new Point[10];}
\noindent to allocate an array of ten references to Points that are initialized
to the null reference. Notice that this allocation of an array doesn't actually
allocate any objects of the Point class for you; you will have to also allocate
the Point objects, something like this:
{\medbreak\narrower\obeylines\obeyspaces\tt
int  i;
    
for (i = 0;  i < 10;  i++) $\{$
\hskip 0.3in myPoints[i] = new Point();
$\}$\medbreak}
\noindent Access to elements of myPoints can be performed via normal C-style
indexing, but all array accesses are checked to ensure that their indices are
within the range of the array. An exception is generated if the index is
outside the bounds of the array.

The length of an array is stored in the length instance variable of the
specific array: myPoints.length contains the number of elements in myPoints.
For instance, the code fragment:
\oneliner{howMany = myPoints.length;}
\noindent would assign the value 10 to the howMany variable.

The C notion of a pointer to an array of memory elements is gone, and with it,
the arbitrary pointer arithmetic that leads to unreliable code in C. No longer
can you walk off the end of an array, possibly trashing memory and leading to
the famous "delayed-crash" syndrome, where a memory-access violation today
manifests itself hours or days later. Programmers can be confident that array
checking in Java will lead to more robust and reliable code.

\subsection Strings.
Strings are Java programming language objects, not pseudo-arrays of characters
as in C. There are actually two kinds of string objects: the String class is
for read-only (immutable) objects. The StringBuffer class is for string objects
you wish to modify (mutable string objects).

Although strings are Java programming language objects, Java compiler follows
the C tradition of providing a syntactic convenience that C programmers have
enjoyed with C-style strings, namely, the Java compiler understands that a
string of characters enclosed in double quote signs is to be instantiated as a
String object. Thus, the declaration:
\oneliner{String hello = "Hello world!";}
\noindent instantiates an object of the String class behind the scenes and
initializes it with a character string containing the Unicode character
representation of "Hello world!".

Java technology has extended the meaning of the + operator to indicate string
concatenation. Thus you can write statements like:
\oneliner{System.out.println("There are " + num + " characters in the file.");}
\noindent This code fragment concatenates the string "There are " with the
result of converting the numeric value num to a string, and concatenates that
with the string " characters in the file.". Then it prints the result of those
concatenations on the standard output.

String objects provide a length() accessor method to obtain the number of
characters in the string.

\subsection Multi-Level Break.
The Java programming language has no goto statement. To break or continue
multiple-nested loop or switch constructs, you can place labels on loop and
switch constructs, and then break out of or continue to the block named by the
label. Here's a small fragment of code from the Java programming language
built-in String class:
{\medbreak\narrower\obeylines\tt
test:  for (int i = fromIndex; i + max1 <= max2; i++) $\{$
\hskip 0.6in if (charAt(i) == c0) $\{$
\hskip 0.9in for (int k = 1; k<max1; k++) $\{$
\hskip 1.2in if (charAt(i+k) != str.charAt(k)) $\{$
\hskip 1.5in continue test;
\hskip 1.2in $\}$
\hskip 0.9in $\}$  /*  end of inner for loop  */
\hskip 0.6in $\}$
\hskip 0.3in $\}$ /*  end of outer for loop  */
\medbreak}
\noindent The continue test statement is inside a for loop nested inside
another for loop. By referencing the label test, the continue statement passes
control to the outer for statement. In traditional C, continue statements can
only continue the immediately enclosing block; to continue or exit outer
blocks, programmers have traditionally either used auxiliary Boolean variables
whose only purpose is to determine if the outer block is to be continued or
exited; alternatively, programmers have (mis)used the goto statement to exit
out of nested blocks. Use of labelled blocks in the Java programming language
leads to considerable simplification in programming effort and a major
reduction in maintenance.

The notion of labelled blocks dates back to the mid-1970s, but it hasn't caught
on to any large extent in modern programming languages. Perl is another modern
programming language that implements the concept of labelled blocks. Perl's
next label and last label are equivalent to continue label and break label
statements in Java.

\subsection Memory Management and Garbage Collection.
C and C++ programmers are by now accustomed to the problems of explicitly
managing memory: allocating memory, freeing memory, and keeping track of what
memory can be freed when. Explicit memory management has proved to be a
fruitful source of bugs, crashes, memory leaks, and poor performance.

Java technology completely removes the memory management load from the
programmer. C-style pointers, pointer arithmetic, malloc, and free do not
exist. Automatic garbage collection is an integral part of Java and its
run-time system. While Java technology has a new operator to allocate memory
for objects, there is no explicit free function. Once you have allocated an
object, the run-time system keeps track of the object's status and
automatically reclaims memory when objects are no longer in use, freeing memory
for future use.

Java technology's memory management model is based on objects and references to
objects. Java technology has no pointers. Instead, all references to allocated
storage, which in practice means all references to an object, are through
symbolic "handles". The Java technology memory manager keeps track of
references to objects. When an object has no more references, the object is a
candidate for garbage collection.

Java technology's memory allocation model and automatic garbage collection make
your programming task easier, eliminate entire classes of bugs, and in general
provide better performance than you'd obtain through explicit memory
management. Here's a code fragment that illustrates when garbage collection
happens:
{\medbreak\narrower\obeylines\tt
class ReverseString $\{$
\hskip 0.3in public static String reverseIt(String source) $\{$
\hskip 0.6in int i, len = source.length();
\hskip 0.6in StringBuffer dest = new StringBuffer(len);

\hskip 0.6in for (i = (len - 1); i >= 0; i--) $\{$
\hskip 0.9in dest.appendChar(source.charAt(i));
\hskip 0.6in $\}$
\hskip 0.6in return dest.toString();
\hskip 0.3in $\}$
$\}$\medbreak}
\noindent The variable dest is used as a temporary object reference during
execution of the reverseIt method. When dest goes out of scope (the reverseIt
method returns), the reference to that object has gone away and it's then a
candidate for garbage collection.

\subsection The Background Garbage Collector.
The Java technology garbage collector achieves high performance by taking
advantage of the nature of a user's behavior when interacting with software
applications such as the HotJavaTM browser. The typical user of the typical
interactive application has many natural pauses where they're contemplating the
scene in front of them or thinking of what to do next. The Java run-time system
takes advantage of these idle periods and runs the garbage collector in a low
priority thread when no other threads are competing for CPU cycles. The garbage
collector gathers and compacts unused memory, increasing the probability that
adequate memory resources are available when needed during periods of heavy
interactive use.

This use of a thread to run the garbage collector is just one of many examples
of the synergy one obtains from Java technology's integrated multithreading
capabilities--an otherwise intractable problem is solved in a simple and
elegant fashion.

\subsection Integrated Thread Synchronization.
Java technology supports multithreading, both at the language (syntactic) level
and via support from its run-time system and thread objects. While other
systems have provided facilities for multithreading (usually via "lightweight
process" libraries), building multithreading support into the language itself
provides the programmer with a much easier and more powerful tool for easily
creating thread-safe multithreaded classes. Multithreading is discussed in more
detail in Chapter 7.

\bye

